<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Rust UO server project pt10: Non-blocking connection handling</title>
  <meta name="description" content="I spent yesterday exploring different approaches to making the connection handling in my Ultima Online server non-blocking.">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://yourdomain.com/2023/11/29/rust-uo-server-project-pt10-non-blocking-connection-handling.html">
  <link rel="alternate" type="application/rss+xml" title="this.rob.journal" href="http://yourdomain.com/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">this.rob.journal</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
          <a class="page-link" href="/about">About</a>
          <a class="page-link" href="/tags">Tags</a>
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Rust UO server project pt10: Non-blocking connection handling</h1>
    <p class="post-meta"><time datetime="2023-11-29T14:00:00+00:00" itemprop="datePublished">Nov 29, 2023</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>I spent yesterday exploring different approaches to making the connection handling in my Ultima Online server non-blocking.</p>

<p>Before making any changes, the code in <code class="language-plaintext highlighter-rouge">main.rs</code> looked this like:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/main.rs</span>

<span class="c1">// snip</span>
<span class="k">mod</span> <span class="n">tcp</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// snip</span>

    <span class="nn">tcp</span><span class="p">::</span><span class="nf">start</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And in the <code class="language-plaintext highlighter-rouge">tcp</code> module:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/tcp.rs</span>

<span class="k">use</span> <span class="nn">byteorder</span><span class="p">::{</span><span class="n">BigEndian</span><span class="p">,</span> <span class="n">ByteOrder</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nn">prelude</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">net</span><span class="p">::</span><span class="n">TcpListener</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">net</span><span class="p">::</span><span class="n">TcpStream</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nb">str</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">start</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">listener</span> <span class="o">=</span> <span class="nn">TcpListener</span><span class="p">::</span><span class="nf">bind</span><span class="p">(</span><span class="s">"127.0.0.1:2593"</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">for</span> <span class="n">stream</span> <span class="k">in</span> <span class="n">listener</span><span class="nf">.incoming</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">buffer</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">1024</span><span class="p">];</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">num_bytes_received</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.read</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buffer</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">while</span> <span class="n">num_bytes_received</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nf">parse_packets</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">stream</span><span class="p">);</span>
            <span class="n">buffer</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">1024</span><span class="p">];</span>
            <span class="n">num_bytes_received</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.read</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buffer</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="c1">// the connection has been closed by the client</span>
        <span class="c1">// if num_bytes_received == 0</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// snip</span>
</code></pre></div></div>

<p>The issue with this is that only one client at a time can be connected. Because <code class="language-plaintext highlighter-rouge">stream.read()</code> is blocking, the thread can not get any more connections from the <code class="language-plaintext highlighter-rouge">listener.incoming()</code> iterator until the current connection closes.</p>

<p>This is obviously no good as there’s not much point in a MMORPG which can only be played by one player.</p>

<p>To allow the multiple long lived connections necessary, the server needed to do two things concurrently:</p>

<ol>
  <li>
    <p>Listen for new connections and accept them</p>
  </li>
  <li>
    <p>Repeatedly call <code class="language-plaintext highlighter-rouge">read()</code> on existing connections to receive packets and respond to them</p>
  </li>
</ol>

<h3 id="non-blocking-approach-one-two-threads-and-a-mutex">Non-blocking approach one: two threads and a Mutex</h3>

<p>With this approach the listening and accepting of new connections happens in a separate thread. When a connection is received it is added to a <code class="language-plaintext highlighter-rouge">Mutex&lt;Vec&lt;TcpStream&gt;&gt;</code> which is shared with the other thread. The other thread iterates over this shared vec and reads/writes to each connection.</p>

<p>My first attempt at implementing this looked like this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/tcp.rs</span>

<span class="k">fn</span> <span class="nf">bind</span><span class="p">(</span><span class="n">connections</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">TcpStream</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">listener</span> <span class="o">=</span> <span class="nn">TcpListener</span><span class="p">::</span><span class="nf">bind</span><span class="p">(</span><span class="s">"127.0.0.1:2593"</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="k">for</span> <span class="n">stream</span> <span class="k">in</span> <span class="n">listener</span><span class="nf">.incoming</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">connections</span> <span class="o">=</span> <span class="n">connections</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.peer_addr</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Connection received from: {}"</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
            <span class="n">connections</span><span class="nf">.push</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">start</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">connections</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">TcpStream</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="k">let</span> <span class="n">connections</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Mutex</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">connections</span><span class="p">));</span>

    <span class="nf">bind</span><span class="p">(</span><span class="nn">Arc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">connections</span><span class="p">));</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nn">thread</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">connections</span> <span class="o">=</span> <span class="n">connections</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">next_connections</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">mut</span> <span class="n">stream</span><span class="p">)</span> <span class="o">=</span> <span class="n">connections</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">buffer</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">1024</span><span class="p">];</span>

            <span class="k">let</span> <span class="n">num_bytes_read</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.read</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buffer</span><span class="p">)</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"Reading from stream should not error"</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">num_bytes_read</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.peer_addr</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Connection closed by: {}"</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nf">parse_packets</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">stream</span><span class="p">);</span>
                <span class="n">next_connections</span><span class="nf">.push</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="o">*</span><span class="n">connections</span> <span class="o">=</span> <span class="n">next_connections</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">thread::sleep()</code> call means that for at least 1ms the lock over <code class="language-plaintext highlighter-rouge">connections</code> will be acquirable by the listener thread. This can be reduced but for the purposes of experimenting I didn’t think it necessary. So for a duration of 1ms any waiting connections are accepted by the listener thread. After 1ms the other thread resumes, takes each existing connection (including any just added) and parses and responds to any packets they have received. As soon as each connection has been read once and responded to the loop restarts and the listener thread checks for new connections again.</p>

<p>However this still didn’t allow multiple connections, because there is still a blocking call to <code class="language-plaintext highlighter-rouge">stream.read()</code>. The call blocks the server when the game client is waiting on the player to do something before sending the next packets. No bytes are being sent but the connection is stil open and so the default behaviour of <code class="language-plaintext highlighter-rouge">TcpStream</code> is in effect and the <code class="language-plaintext highlighter-rouge">read()</code> call blocks until the next bytes are sent. Other connections can not be accepted or read from until the client closes the connection.</p>

<p>To work around this I configured each <code class="language-plaintext highlighter-rouge">TcpStream</code> to have the smallest possible read timeout:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/tcp.rs</span>

<span class="k">fn</span> <span class="nf">bind</span><span class="p">(</span><span class="n">connections</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">TcpStream</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="c1">// snip</span>

        <span class="k">for</span> <span class="n">stream</span> <span class="k">in</span> <span class="n">listener</span><span class="nf">.incoming</span><span class="p">()</span> <span class="p">{</span>
            <span class="c1">//snip</span>

            <span class="k">let</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="n">stream</span>
                <span class="nf">.set_read_timeout</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_nanos</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>
                <span class="nf">.expect</span><span class="p">(</span><span class="s">"set_read_timeout call failed"</span><span class="p">);</span>

            <span class="c1">// snip</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now <code class="language-plaintext highlighter-rouge">read()</code> will only block for 1 nanosecond before either returning a <code class="language-plaintext highlighter-rouge">Result::Ok</code> containing <code class="language-plaintext highlighter-rouge">num_bytes_read</code> or a <code class="language-plaintext highlighter-rouge">Result::Err</code> of the <code class="language-plaintext highlighter-rouge">WouldBlock</code> kind. The rest of the code needed updating as below to handle this different behaviour:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">start</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// snip</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="c1">// snip</span>

        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">mut</span> <span class="n">stream</span><span class="p">)</span> <span class="o">=</span> <span class="n">connections</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
            <span class="c1">// snip</span>

            <span class="k">let</span> <span class="n">read_result</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.read</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buffer</span><span class="p">);</span>

            <span class="k">match</span> <span class="n">read_result</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">num_bytes_read</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="n">num_bytes_read</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                        <span class="k">let</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.peer_addr</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                        <span class="nd">println!</span><span class="p">(</span><span class="s">"Connection closed by: {}"</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="nf">parse_packets</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">stream</span><span class="p">);</span>
                        <span class="n">next_connections</span><span class="nf">.push</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">match</span> <span class="n">e</span><span class="nf">.kind</span><span class="p">()</span> <span class="p">{</span>
                    <span class="n">WouldBlock</span> <span class="k">=&gt;</span> <span class="n">next_connections</span><span class="nf">.push</span><span class="p">(</span><span class="n">stream</span><span class="p">),</span>
                    <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Unexpected error from stream.read(): {:?}"</span><span class="p">,</span> <span class="n">e</span><span class="p">),</span>
                <span class="p">},</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// snip</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If a <code class="language-plaintext highlighter-rouge">Result::Err</code> of the <code class="language-plaintext highlighter-rouge">WouldBlock</code> kind is returned from <code class="language-plaintext highlighter-rouge">stream.read()</code>, it indicates that the connection is still alive and well but no bytes have been sent by the client since the last read. The connection is pushed to <code class="language-plaintext highlighter-rouge">next_connections</code> in this case so that it can be checked again on the next iteration of the loop.</p>

<p>If any other type of <code class="language-plaintext highlighter-rouge">Result::Err</code> is returned, the error is printed and the connection is <em>not</em> added to <code class="language-plaintext highlighter-rouge">next_connections</code> to be checked on the next loop iteration.</p>

<p>The full code for this approach can be seen in <a href="https://github.com/thisdotrob/rust-uo-server/tree/98c3641177aa20a9802b4dd63c103b8aa88e4336">this commit</a>.</p>

<p>I also refactored the code above slightly to use <code class="language-plaintext highlighter-rouge">retain_mut()</code> on the <code class="language-plaintext highlighter-rouge">connections</code> vec to avoid needing a separate <code class="language-plaintext highlighter-rouge">next_connections</code> vec - see <a href="https://github.com/thisdotrob/rust-uo-server/tree/1af0e99931279eee34f5f785ec8a07f79ea883ac">this commit</a>.</p>

<p>One potential risk I can see with this approach is that anyone maliciously sending a significant amount of new connections to the server could make it hard for the second thread to acquire a lock on the connections vec, slowing down communication with existing clients. This could be fixed by adding throttling to the listener thread, which would introduce a delay that must happen before locking the vec and accepting a connection.</p>

<h3 id="non-blocking-approach-two-one-thread">Non-blocking approach two: one thread</h3>

<p>With this approach I made the loop check once for new connections on each iteration and then proceed. In the previous approach the <code class="language-plaintext highlighter-rouge">TcpListener</code> was treated as an iterator when checking for new connections:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">listener</span> <span class="o">=</span> <span class="nn">TcpListener</span><span class="p">::</span><span class="nf">bind</span><span class="p">(</span><span class="s">"127.0.0.1:2593"</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

<span class="k">for</span> <span class="n">stream</span> <span class="k">in</span> <span class="n">listener</span><span class="nf">.incoming</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="c1">// do something with the new connection</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is blocking, preventing anything else happening after the for loop.</p>

<p>An alternative way of accepting new connections is to use the <code class="language-plaintext highlighter-rouge">accept()</code> method instead of treating the listener as an iterator:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="k">let</span> <span class="nf">Ok</span><span class="p">((</span><span class="n">stream</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span> <span class="o">=</span> <span class="n">listener</span><span class="nf">.accept</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// do something with the new connection</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is still blocking however, as <code class="language-plaintext highlighter-rouge">accept()</code> blocks until a new connection is received.</p>

<p>To make it non-blocking, the <code class="language-plaintext highlighter-rouge">TcpListener</code> can be set to non-blocking mode:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">listener</span> <span class="o">=</span> <span class="nn">TcpListener</span><span class="p">::</span><span class="nf">bind</span><span class="p">(</span><span class="s">"127.0.0.1:2593"</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
<span class="n">listener</span>
    <span class="nf">.set_nonblocking</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
    <span class="nf">.expect</span><span class="p">(</span><span class="s">"Cannot set non-blocking"</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">accept()</code> will now not not block, and either return the new connection <em>or</em> a <code class="language-plaintext highlighter-rouge">Result::Err</code> of the <code class="language-plaintext highlighter-rouge">WouldBlock</code> kind.</p>

<p>After setting the listener to non blocking mode as above I was able to use a simple <code class="language-plaintext highlighter-rouge">if let</code> statement to check for new connections once per loop iteration:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/tcp.rs</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">start</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">listener</span> <span class="o">=</span> <span class="nn">TcpListener</span><span class="p">::</span><span class="nf">bind</span><span class="p">(</span><span class="s">"127.0.0.1:2593"</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="n">listener</span>
        <span class="nf">.set_nonblocking</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
        <span class="nf">.expect</span><span class="p">(</span><span class="s">"Cannot set non-blocking"</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">connections</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">TcpStream</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nn">thread</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Ok</span><span class="p">((</span><span class="n">stream</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span> <span class="o">=</span> <span class="n">listener</span><span class="nf">.accept</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Connection received from: {}"</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
            <span class="n">stream</span>
                <span class="nf">.set_read_timeout</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_nanos</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>
                <span class="nf">.expect</span><span class="p">(</span><span class="s">"set_read_timeout call failed"</span><span class="p">);</span>
            <span class="n">connections</span><span class="nf">.push</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// iterate over connections and read from / write to them</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>See <a href="https://github.com/thisdotrob/rust-uo-server/tree/03042d8f53cf05f9f65de433189a95c946ac05ef">this commit</a> for the full code for this approach.</p>

<p>This approach doesn’t risk being overloaded with connection requests since a maximum of one connection is accepted every 1 millisecond. But it might be slower because the check for new connections with <code class="language-plaintext highlighter-rouge">accept()</code> occurs on every iteration of the loop. The previous approach ran the checking in a separate thread and so only interrupted the other thread when a new connection had actually been received.</p>

<h3 id="non-blocking-approach-three-using-an-async-runtime">Non-blocking approach three: using an async runtime</h3>

<p>My third approach to non-blocking TCP connections was to use an async runtime to allow concurrent packet handling and connection accepting.</p>

<p>The runtime I chose was <a href="https://github.com/async-rs/async-std">async-std</a>, purely because that’s what I have most familiarity with.</p>

<p>My async approach has two main async functions:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">fn</span> <span class="nf">connection_loop</span><span class="p">(</span><span class="k">mut</span> <span class="n">stream</span><span class="p">:</span> <span class="n">TcpStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">buffer</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">1024</span><span class="p">];</span>

    <span class="k">while</span> <span class="k">let</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">received</span><span class="p">)</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.read</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buffer</span><span class="p">)</span><span class="k">.await</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">received</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.peer_addr</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Connection closed by: {}"</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">parse_packets</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">stream</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
            <span class="n">buffer</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">1024</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">async</span> <span class="k">fn</span> <span class="nf">accept_loop</span><span class="p">(</span><span class="n">addr</span><span class="p">:</span> <span class="k">impl</span> <span class="n">ToSocketAddrs</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">listener</span> <span class="o">=</span> <span class="nn">TcpListener</span><span class="p">::</span><span class="nf">bind</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">incoming</span> <span class="o">=</span> <span class="n">listener</span><span class="nf">.incoming</span><span class="p">();</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span> <span class="o">=</span> <span class="n">incoming</span><span class="nf">.next</span><span class="p">()</span><span class="k">.await</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">stream</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.peer_addr</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Connection received from: {}"</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
        <span class="nn">task</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="nf">connection_loop</span><span class="p">(</span><span class="n">stream</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">start</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">fut</span> <span class="o">=</span> <span class="nf">accept_loop</span><span class="p">(</span><span class="s">"127.0.0.1:2593"</span><span class="p">);</span>
    <span class="nn">task</span><span class="p">::</span><span class="nf">block_on</span><span class="p">(</span><span class="n">fut</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">accept_loop()</code> uses the <code class="language-plaintext highlighter-rouge">async-std</code> version of <code class="language-plaintext highlighter-rouge">TcpListener</code> to asynchronously wait for new connections. Because there is no support for async for loops in Rust yet, a <code class="language-plaintext highlighter-rouge">while let Some()</code> is needed here. For each new connection received, an asychnronous task is spawned to start the <code class="language-plaintext highlighter-rouge">connection_loop()</code> function.</p>

<p><code class="language-plaintext highlighter-rouge">connection_loop()</code> uses the <code class="language-plaintext highlighter-rouge">async-std</code> version of <code class="language-plaintext highlighter-rouge">TcpStream</code> to read bytes and pass them to <code class="language-plaintext highlighter-rouge">parse_packets()</code>. As before, the <code class="language-plaintext highlighter-rouge">TcpStream</code> is passed to <code class="language-plaintext highlighter-rouge">parse_packets()</code> so that it can be used to send responses to the client. Now that the async version of <code class="language-plaintext highlighter-rouge">TcpStream</code> is being passed, <code class="language-plaintext highlighter-rouge">parse_packets()</code> and the functions it calls need to be converted to async too:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">fn</span> <span class="nf">parse_packets</span><span class="p">(</span><span class="n">buffer</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">1024</span><span class="p">],</span> <span class="k">mut</span> <span class="n">stream</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">TcpStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">buffer_slice</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="o">..</span><span class="p">];</span>

    <span class="k">while</span> <span class="n">buffer_slice</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">packet_id</span> <span class="o">=</span> <span class="nf">read_u8</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buffer_slice</span><span class="p">);</span>

        <span class="k">match</span> <span class="n">packet_id</span> <span class="p">{</span>
            <span class="c1">// snip</span>
            <span class="mi">0x80</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nf">handle_account_login_request_packet</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buffer_slice</span><span class="p">);</span>
                <span class="nf">send_server_list_packet</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">stream</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span> <span class="c1">// &lt;-- async function</span>
            <span class="p">}</span>
            <span class="c1">// snip</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="k">continue</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">async</span> <span class="k">fn</span> <span class="nf">send_server_list_packet</span><span class="p">(</span><span class="n">stream</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">TcpStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">buffer</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">46</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">46</span><span class="p">];</span>

    <span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0xA8</span><span class="p">;</span> <span class="c1">// packet ID</span>

    <span class="n">buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0x2E</span><span class="p">;</span> <span class="c1">// packet length</span>

    <span class="c1">// snip</span>

    <span class="n">stream</span><span class="nf">.write_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span> <span class="c1">// &lt;-- using the async-std version</span>
    <span class="n">stream</span><span class="nf">.flush</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span> <span class="c1">// &lt;------------|</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">Result&lt;()&gt;</code> used for the return types in the code above is an alias:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">result</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span> <span class="o">+</span> <span class="nb">Send</span> <span class="o">+</span> <span class="nb">Sync</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">Send</code> and <code class="language-plaintext highlighter-rouge">Sync</code> traits are needed in order to use <code class="language-plaintext highlighter-rouge">async-std</code>’s <code class="language-plaintext highlighter-rouge">task::spawn</code> because the async executor uses a thread pool behind the scenes. This tells the compiler that the <code class="language-plaintext highlighter-rouge">E</code> in the <code class="language-plaintext highlighter-rouge">Result&lt;T, E&gt;</code> is safe to be moved between threads, as <code class="language-plaintext highlighter-rouge">task::spawn</code> tells it it needs to be.</p>

<p>The full code for this approach is in <a href="https://github.com/thisdotrob/rust-uo-server/tree/7eacf2f5e6499c35a1b1f1bfe84ca1d09874db45">this commit</a>.</p>

<h3 id="wrap-up">Wrap up</h3>

<p>I’m going to go with the third approach and use async. This is because it’s best suited to a situation where there are lots of tasks and not so many threads available to be used, especially when time is typically spent waiting in each task. This is the situation I anticipate for the server given that there will be lots of connections and a limited number of threads available to the networking portion of it, and often the tasks will be waiting for bytes from the client. Instead of only having two threads as in the first approach or spinning up so many threads that the CPU spends a lot of time switching between them, async will allow keeping the number of threads to the optimal amount - within the number of virtual cpu cores available.</p>

  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">this.rob.journal</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li><a href="mailto:this.rob@protonmail.com">this.rob@protonmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/thisdotrob"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">thisdotrob</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/thisdotrob"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">thisdotrob</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>A place to document and share my explorations in coding. Mainly so I can go back and copy paste when I forget how to do something ;)
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>

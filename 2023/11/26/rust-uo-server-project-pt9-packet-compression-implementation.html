<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Rust UO server project pt9: Packet compression implementation</title>
  <meta name="description" content="I’ve spent the last day implementing the Huffman coding compression logic I needed for my Ultima Online server project. This logic will be used to compress o...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://yourdomain.com/2023/11/26/rust-uo-server-project-pt9-packet-compression-implementation.html">
  <link rel="alternate" type="application/rss+xml" title="this.rob.journal" href="http://yourdomain.com/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">this.rob.journal</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
          <a class="page-link" href="/about">About</a>
          <a class="page-link" href="/tags">Tags</a>
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Rust UO server project pt9: Packet compression implementation</h1>
    <p class="post-meta"><time datetime="2023-11-26T18:00:00+00:00" itemprop="datePublished">Nov 26, 2023</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>I’ve spent the last day implementing the Huffman coding compression logic I needed for my Ultima Online server project. This logic will be used to compress outgoing packets from the server to the client, after the player has selected the shard they want to play on.</p>

<p>This is the first part of my server implementation I have built for which I’m confident that the design will stick and no <em>big</em> changes will be needed later on. For that reason I spent a decent amount of time writing unit tests, and an integration test that verifies it will work for the purposes of an Ultima Online server. I opted not to write tests for the other parts of the server I’ve written so far, since I’ve been hacking away and experimenting. Manual testing is much faster for that kind of workflow, but I’ll be going back and adding tests when a more final design has evolved and all the shortcuts in terms of skipped functionality need addressing.</p>

<p>I chose to implement the logic as a separate crate that can be used to compress bytes for any project, not just an Ultima Online server. The full code is on GitHub: <a href="https://github.com/thisdotrob/rust_huffman_compression">thisdotrob/rust_huffman_compression</a>. I may end up making it Ultima Online specific but still keep it as a crate. Perhaps this way others wanting to build Ultima Online servers or clients will be able to use it too. This has got me thinking what other components of the server could be written as crates for others to use modularly.</p>

<h2 id="using-the-crate">Using the crate</h2>

<p>This is mostly lifted from the crate’s readme…</p>

<h3 id="getting-started">Getting started</h3>

<p>First construct a <code class="language-plaintext highlighter-rouge">HuffmanTable</code> which represents the encoding rules:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">values</span><span class="p">:</span> <span class="p">[</span><span class="nb">u32</span><span class="p">;</span> <span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="mi">0b1111</span><span class="p">,</span> <span class="mi">0b0111</span><span class="p">,</span> <span class="mi">0b1011</span><span class="p">,</span> <span class="mi">0b110</span><span class="p">,</span>
    <span class="c1">// snip</span>
<span class="p">];</span>

<span class="k">let</span> <span class="n">bit_counts</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>
    <span class="c1">// snip</span>
<span class="p">];</span>

<span class="k">let</span> <span class="n">table</span> <span class="o">=</span> <span class="n">HuffmanTable</span> <span class="p">{</span> <span class="n">values</span><span class="p">,</span> <span class="n">bit_counts</span> <span class="p">};</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">values</code> are the compressed bits that should be written for corresponding uncompressed bytes. <code class="language-plaintext highlighter-rouge">bit_counts</code> are the number of bits that should be written for each encoded value. The correct value and bit_count for each uncompressed byte are looked up by using that byte as an index to look up the elements in the two arrays.</p>

<p>For example, given an uncompressed byte of 0x03:</p>
<ul>
  <li>The value, <code class="language-plaintext highlighter-rouge">0b110</code>, lies at index 3 (i.e. <code class="language-plaintext highlighter-rouge">0x03</code>) of <code class="language-plaintext highlighter-rouge">values</code></li>
  <li>The bit count, <code class="language-plaintext highlighter-rouge">4</code>,  lies at index 3 (again, <code class="language-plaintext highlighter-rouge">0x03</code>) of <code class="language-plaintext highlighter-rouge">bit_counts</code></li>
  <li>The final compressed bits are the value after is has been left padded with 0s until the bit_count is reached. In this case that means <code class="language-plaintext highlighter-rouge">0110</code> is written.</li>
</ul>

<p>The example above shows only the first 4 elements for each array but in reality you will need to populate all 256.</p>

<p>Next create a <code class="language-plaintext highlighter-rouge">Huffman</code>, passing it the table:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">huffman</span> <span class="o">=</span> <span class="nn">Huffman</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="nb">None</span><span class="p">);</span> <span class="c1">// &lt;-- the None is for the termination code, see further down</span>
</code></pre></div></div>

<p>Now, send bytes to be compressed and an output vec for the compressed bits to be pushed to:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">uncompressed_bytes</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x01</span><span class="p">,</span> <span class="mi">0x02</span><span class="p">,</span> <span class="mi">0x03</span><span class="p">];</span>

<span class="k">let</span> <span class="k">mut</span> <span class="n">output</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

<span class="n">huffman</span><span class="nf">.compress</span><span class="p">(</span><span class="n">uncompressed_bytes</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">output</span><span class="p">);</span>
</code></pre></div></div>

<p>Now we can see that <code class="language-plaintext highlighter-rouge">output</code> has been populated with the compressed bits, separated into bytes:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// as binary with underscores separating the original compressed bit groupings:</span>
<span class="nd">assert_eq!</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0b1111_0111</span><span class="p">,</span> <span class="mi">0b1011_0110</span><span class="p">]);</span>

<span class="c1">// or as hex:</span>
<span class="nd">assert_eq!</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0xF7</span><span class="p">,</span> <span class="mi">0xB6</span><span class="p">]);</span>
</code></pre></div></div>

<h3 id="byte-boundaries-and-termination-codes">Byte boundaries and termination codes</h3>

<p>If the compressed bits do not align with a byte boundary like they do in the example above, the crate will pad with zeroes:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// using the same table as in the previous example</span>

<span class="k">let</span> <span class="n">uncompressed_bytes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x01</span><span class="p">,</span> <span class="mi">0x02</span><span class="p">];</span>

<span class="n">huffman</span><span class="nf">.compress</span><span class="p">(</span><span class="n">uncompressed_bytes</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">output</span><span class="p">);</span>

<span class="c1">// the compressed bits will now be 0b1111_0111_1011. This is only one and a half bytes, so</span>
<span class="c1">// four zeroes are added to the end to make up to the next byte boundary:</span>
<span class="nd">assert_eq!</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0b1111_0111</span><span class="p">,</span> <span class="mi">0b1011_0000</span><span class="p">]);</span>
</code></pre></div></div>

<p>This is fine so long as the zeroes added for padding do not clash with one of the compressed values for a byte. For example if a 0x04 byte had a compressed value of <code class="language-plaintext highlighter-rouge">0b00</code> and bit count of 2, the last four bits in the example above would decompress to two 0x04 bytes which is not what we want.</p>

<p>To avoid this, it is possible to append a termination code to the compressed bits which will signal to the consuming code that any bits following do not represent compressed bytes and should be ignored:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// this time, set up the Huffman with a TerminalCode:</span>

<span class="k">let</span> <span class="n">terminal_code</span> <span class="o">=</span> <span class="n">TerminalCode</span> <span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="mi">0b001</span><span class="p">,</span> <span class="n">bit_count</span><span class="p">:</span> <span class="mi">3</span> <span class="p">};</span>
<span class="k">let</span> <span class="n">huffman</span> <span class="o">=</span> <span class="nn">Huffman</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">terminal_code</span><span class="p">));</span>

<span class="c1">// compress as normal:</span>

<span class="k">let</span> <span class="n">uncompressed_bytes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x01</span><span class="p">,</span> <span class="mi">0x02</span><span class="p">];</span>
<span class="n">huffman</span><span class="nf">.compress</span><span class="p">(</span><span class="n">uncompressed_bytes</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">output</span><span class="p">);</span>

<span class="c1">// now the termination code is appended to the output before padding with zeroes:</span>

<span class="nd">assert_eq!</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0b1111_0111</span><span class="p">,</span> <span class="mi">0b1011_001_0</span><span class="p">]);</span>
<span class="c1">//                                           ^</span>
<span class="c1">//                                  termination code</span>
</code></pre></div></div>

<h2 id="code-walkthrough">Code walkthrough</h2>

<p>The entrypoint to the crate is the <code class="language-plaintext highlighter-rouge">Huffman</code> struct:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/lib.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Huffman</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">table</span><span class="p">:</span> <span class="n">HuffmanTable</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">terminal_code</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">TerminalCode</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Huffman</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">table</span><span class="p">:</span> <span class="n">HuffmanTable</span><span class="p">,</span> <span class="n">terminal_code</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">TerminalCode</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Huffman</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Huffman</span> <span class="p">{</span>
            <span class="n">terminal_code</span><span class="p">,</span>
            <span class="n">table</span><span class="p">,</span>
        <span class="p">};</span>
    <span class="p">}</span>

    <span class="c1">// snip</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The initialiser takes a <code class="language-plaintext highlighter-rouge">HuffmanTable</code> containing the compressed bit values and their corresponding bit counts, and an optional <code class="language-plaintext highlighter-rouge">TerminalCode</code>, which will be appended once the last compressed bit is written.</p>

<p>A <code class="language-plaintext highlighter-rouge">Huffman</code> has a single <code class="language-plaintext highlighter-rouge">compress()</code> method:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/lib.rs</span>

<span class="k">impl</span> <span class="n">Huffman</span> <span class="p">{</span>

    <span class="c1">// snip</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">compress</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">output</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">compressor</span> <span class="o">=</span> <span class="nn">Compressor</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.table</span><span class="p">);</span>

        <span class="k">for</span> <span class="n">byte</span> <span class="k">in</span> <span class="n">src</span> <span class="p">{</span>
            <span class="n">compressor</span><span class="nf">.compress_byte</span><span class="p">(</span><span class="n">byte</span><span class="p">);</span>

            <span class="k">for</span> <span class="n">compressed_byte</span> <span class="k">in</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">compressor</span> <span class="p">{</span>
                <span class="n">output</span><span class="nf">.push</span><span class="p">(</span><span class="n">compressed_byte</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">terminal_code</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.terminal_code</span> <span class="p">{</span>
            <span class="n">compressor</span><span class="nf">.append_terminal_code</span><span class="p">(</span><span class="n">terminal_code</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">compressor</span><span class="nf">.end</span><span class="p">();</span>

        <span class="k">for</span> <span class="n">compressed_byte</span> <span class="k">in</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">compressor</span> <span class="p">{</span>
            <span class="n">output</span><span class="nf">.push</span><span class="p">(</span><span class="n">compressed_byte</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">compress()</code> takes a <code class="language-plaintext highlighter-rouge">src</code> of uncompressed bytes and a <code class="language-plaintext highlighter-rouge">Vec&lt;u8&gt;</code> to put the compressed <code class="language-plaintext highlighter-rouge">output</code> in. It iterates over the uncompressed bytes and uses the <code class="language-plaintext highlighter-rouge">compress_byte()</code> method on a <code class="language-plaintext highlighter-rouge">Compressor</code> struct instance to compress it. The <code class="language-plaintext highlighter-rouge">TerminalCode</code> is appended if provided, once all bytes have been compressed. To align on the byte boundary, <code class="language-plaintext highlighter-rouge">end()</code> is called. Any extra compressed bits written during aligning are then added to the <code class="language-plaintext highlighter-rouge">output</code>.</p>

<p>The <code class="language-plaintext highlighter-rouge">Compressor</code> struct takes a reference to the <code class="language-plaintext highlighter-rouge">HuffmanTable</code> and initialises a new <code class="language-plaintext highlighter-rouge">CompressorBuffer</code> which is used to build up the compressed bits:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/compressor.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Compressor</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">table</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">HuffmanTable</span><span class="p">,</span>
    <span class="n">buffer</span><span class="p">:</span> <span class="n">CompressorBuffer</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Compressor</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">table</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">HuffmanTable</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">Compressor</span> <span class="p">{</span>
            <span class="n">table</span><span class="p">,</span>
            <span class="n">buffer</span><span class="p">:</span> <span class="nn">CompressorBuffer</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// snip</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The lifetime parameter <code class="language-plaintext highlighter-rouge">'a</code> signals that the <code class="language-plaintext highlighter-rouge">HuffmanTable</code> reference needs to live at least as long as the struct itself.</p>

<p>The <code class="language-plaintext highlighter-rouge">compress_byte()</code> method on <code class="language-plaintext highlighter-rouge">Compressor</code> takes an uncompressed byte, looks up the compressed bit count and value and passes them to the buffer to write.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/compressor.rs</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Compressor</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// snip</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">compress_byte</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">byte</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="k">self</span><span class="py">.table</span><span class="nf">.get_compressed_value</span><span class="p">(</span><span class="n">byte</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">bit_count</span> <span class="o">=</span> <span class="k">self</span><span class="py">.table</span><span class="nf">.get_compressed_value_bit_count</span><span class="p">(</span><span class="n">byte</span><span class="p">);</span>
        <span class="k">self</span><span class="py">.buffer</span><span class="nf">.write_bits</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">bit_count</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// snip</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Compressor</code> has two other methods that write to the buffer:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/compressor.rs</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Compressor</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// snip</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">append_terminal_code</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">terminal_code</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">TerminalCode</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.buffer</span>
            <span class="nf">.write_bits</span><span class="p">(</span><span class="n">terminal_code</span><span class="py">.value</span><span class="p">,</span> <span class="n">terminal_code</span><span class="py">.bit_count</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">end</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">byte_boundary_offset</span> <span class="o">=</span> <span class="k">self</span><span class="py">.buffer</span><span class="nf">.byte_boundary_offset</span><span class="p">();</span>

        <span class="k">if</span> <span class="n">byte_boundary_offset</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">padding_value</span> <span class="o">=</span> <span class="mi">0b0</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">padding_bit_count</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">-</span> <span class="n">byte_boundary_offset</span><span class="p">;</span>
            <span class="k">self</span><span class="py">.buffer</span><span class="nf">.write_bits</span><span class="p">(</span><span class="n">padding_value</span><span class="p">,</span> <span class="n">padding_bit_count</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// snip</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">append_terminal_code()</code> takes a <code class="language-plaintext highlighter-rouge">TerminalCode</code> and passes it’s compressed value and bit count to the buffer for writing. <code class="language-plaintext highlighter-rouge">end()</code> asks the buffer for the current offset from the byte boundary and asks it to write zeroes up to the next boundary so that a full last byte can be read. This logic should be the responsibility of the buffer itself, something I’ll refactor later.</p>

<p>After bits have been written to the buffer, full compressed bytes can be read with the <code class="language-plaintext highlighter-rouge">get_compressed_byte()</code> method:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/compressor.rs</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Compressor</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// snip</span>

    <span class="k">fn</span> <span class="nf">get_compressed_byte</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.buffer</span><span class="nf">.read_byte</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This will return <code class="language-plaintext highlighter-rouge">Option::None</code> if there are no full bytes of compressed bits left to be read.</p>

<p>The <code class="language-plaintext highlighter-rouge">Compressor</code> struct doesn’t seem to do much more than call out to methods on <code class="language-plaintext highlighter-rouge">CompressorBuffer</code>, but it is a useful layer to abstract over the buffer API and is also where the <code class="language-plaintext highlighter-rouge">Iterator</code> trait is implemented so that compressed bytes can be read in a <code class="language-plaintext highlighter-rouge">for</code> loop:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/compressor.rs</span>

<span class="c1">// snip</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="nb">Iterator</span> <span class="k">for</span> <span class="n">Compressor</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="nb">u8</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.get_compressed_byte</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Lastly, the buffer itself, <code class="language-plaintext highlighter-rouge">CompressorBuffer</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/compressor/buffer.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">CompressorBuffer</span> <span class="p">{</span>
    <span class="n">compressed_bits</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="n">compressed_bit_count</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">CompressorBuffer</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">compressed_bits</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">compressed_bit_count</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// snip</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The initialiser sets two private properties to 0: <code class="language-plaintext highlighter-rouge">compressed_bits</code> stores the sequence of actual compressed values that haven’t been read yet and <code class="language-plaintext highlighter-rouge">compressed_bit_count</code> keeps track of how many compressed bits have been written but not read yet.</p>

<p><code class="language-plaintext highlighter-rouge">write_bits()</code> takes a compressed value and a bit count for that value (both previously looked up in the <code class="language-plaintext highlighter-rouge">HuffmanTable</code>), left shifts <code class="language-plaintext highlighter-rouge">compressed_bits</code> and appends the value and then increments <code class="language-plaintext highlighter-rouge">compressed_bit_count</code> by the value’s bit count.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/compressor/buffer.rs</span>

<span class="k">impl</span> <span class="n">CompressorBuffer</span> <span class="p">{</span>
    <span class="c1">// snip</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">write_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">bit_count</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.compressed_bits</span> <span class="o">=</span> <span class="k">self</span><span class="py">.compressed_bits</span> <span class="o">&lt;&lt;</span> <span class="n">bit_count</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.compressed_bits</span> <span class="o">=</span> <span class="k">self</span><span class="py">.compressed_bits</span> <span class="p">|</span> <span class="n">value</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.compressed_bit_count</span> <span class="o">=</span> <span class="k">self</span><span class="py">.compressed_bit_count</span> <span class="o">+</span> <span class="n">bit_count</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// snip</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">read_byte()</code> returns <code class="language-plaintext highlighter-rouge">Option::None</code> if there are less than a byte’s worth of compressed values. Otherwise it removes and returns a byte by right shifting and applying a mask to leave only the first 8 bits in the compressed sequence, leaving the remainder there:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/compressor/buffer.rs</span>

<span class="k">impl</span> <span class="n">CompressorBuffer</span> <span class="p">{</span>
    <span class="c1">// snip</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">read_byte</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.compressed_bit_count</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="py">.compressed_bit_count</span> <span class="o">=</span> <span class="k">self</span><span class="py">.compressed_bit_count</span> <span class="o">-</span> <span class="mi">8</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">byte</span> <span class="o">=</span> <span class="k">self</span><span class="py">.compressed_bits</span> <span class="o">&gt;&gt;</span> <span class="k">self</span><span class="py">.compressed_bit_count</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">mask</span> <span class="o">=</span> <span class="k">if</span> <span class="k">self</span><span class="py">.compressed_bit_count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nn">u32</span><span class="p">::</span><span class="n">MAX</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="k">self</span><span class="py">.compressed_bit_count</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="mi">0</span>
        <span class="p">};</span>

        <span class="k">self</span><span class="py">.compressed_bits</span> <span class="o">=</span> <span class="k">self</span><span class="py">.compressed_bits</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>

        <span class="nf">Some</span><span class="p">(</span><span class="n">byte</span> <span class="k">as</span> <span class="nb">u8</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The internal buffer (<code class="language-plaintext highlighter-rouge">compressed_bits</code>) is implemented as a <code class="language-plaintext highlighter-rouge">u32</code>. This means that if the compressed values written to it exceed 32 bits the program will panic. This is okay since I have control over the calling code (in <code class="language-plaintext highlighter-rouge">Compressor</code>) which always attempts to read a byte in between each write of a compressed value. A single compressed value cannot exceed 32 bits since they are stored in <code class="language-plaintext highlighter-rouge">HuffmanTable</code>’s <code class="language-plaintext highlighter-rouge">values</code> array which is declared to take only <code class="language-plaintext highlighter-rouge">u32</code> elements:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/huffman_table.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">HuffmanTable</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">values</span><span class="p">:</span> <span class="p">[</span><span class="nb">u32</span><span class="p">;</span> <span class="mi">256</span><span class="p">],</span>

    <span class="c1">// snip</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If the <code class="language-plaintext highlighter-rouge">CompressorBuffer</code> needed to be used elsewhere at some point, in a place where it couldn’t be guaranteed bytes would be read often enough to prevent the overflow described above, then I’d need to consider approaches to allowing the internal buffer to grow dynamically.</p>

<h2 id="performance">Performance</h2>

<p>I’m looking forward to benchmarking this code and seeing how it stacks up with the ServUO implementation. I’ll return to this in the future as I’m keen to use it in my server ASAP, see if I can progress past the login flow and get a character appearing in game.</p>

<h2 id="next-steps">Next steps</h2>

<p>Use this compression lib in the server! This should allow it to progress past the shard selection screen and allow implementing the next packets which are for character creation and selection.</p>

<p>To see the full code for the crate, see the github repo: <a href="https://github.com/thisdotrob/rust_huffman_compression/">thisdotrob/rust_huffman_compression</a></p>

  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">this.rob.journal</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li><a href="mailto:this.rob@protonmail.com">this.rob@protonmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/thisdotrob"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">thisdotrob</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/thisdotrob"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">thisdotrob</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>A place to document and share my explorations in coding. Mainly so I can go back and copy paste when I forget how to do something ;)
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>

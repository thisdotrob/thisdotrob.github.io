<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Rust UO server project pt3: Adding Timer Callbacks</title>
  <meta name="description" content="Today I’ve carried on working on the timer logic in my Ultima Online server implementation project. Previously the logic only displayed progress bars that in...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://yourdomain.com/2023/10/31/rust-uo-server-project-pt3-adding-timer-callbacks.html">
  <link rel="alternate" type="application/rss+xml" title="this.rob.journal" href="http://yourdomain.com/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">this.rob.journal</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
          <a class="page-link" href="/about">About</a>
          <a class="page-link" href="/tags">Tags</a>
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Rust UO server project pt3: Adding Timer Callbacks</h1>
    <p class="post-meta"><time datetime="2023-10-31T17:00:00+00:00" itemprop="datePublished">Oct 31, 2023</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Today I’ve carried on working on the timer logic in my Ultima Online server implementation project. Previously the logic only displayed progress bars that incremented as each repetition of a timer was run. Next I needed to implement functionality to allow some arbitrary code to be run when a timer is executed. This is the whole point of having timers - execute some logic at a certain time or at certain intervals.</p>

<p>This journal post documents my exploration of storing a callback on the <code class="language-plaintext highlighter-rouge">Timer</code> struct to be called by the timer execution thread. The logic that runs on each execution will need to modify some game state e.g. a character’s hitpoints, so this post also explores how state can be passed to a callback property on a struct.</p>

<p>My first thought for how to implement the callback on the <code class="language-plaintext highlighter-rouge">Timer</code> struct was to set it as a <code class="language-plaintext highlighter-rouge">callback</code> property with the value being a closure. I wasn’t sure what type to give the property, so explored that first:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">Timer</span> <span class="p">{</span>
    <span class="c1">// snip</span>
    <span class="n">callback</span><span class="p">:</span> <span class="o">????</span><span class="p">,</span> <span class="c1">// some sort of closure type?</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Closures do not have concrete types that can be used in a struct definition, but there are three traits that closures can implement: <code class="language-plaintext highlighter-rouge">Fn</code>, <code class="language-plaintext highlighter-rouge">FnOnce</code> and <code class="language-plaintext highlighter-rouge">FnMut</code>.</p>

<p>To use one of these traits to specify the type of <code class="language-plaintext highlighter-rouge">callback</code>, a trait object would be necessary e.g.:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Timer</span> <span class="p">{</span>
    <span class="n">callback</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nf">Fn</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="p">()</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="using-a-fnonce-trait-object-for-the-callback">Using a <code class="language-plaintext highlighter-rouge">FnOnce</code> trait object for the callback</h3>

<p><code class="language-plaintext highlighter-rouge">FnOnce</code> is implemented by closures which can only be called once. <code class="language-plaintext highlighter-rouge">Timer</code> structs need to be able to have the callback called multiple times, once for each repetition. So using a <code class="language-plaintext highlighter-rouge">FnOnce</code> closure would therefore not work and we’ll get the error demonstrated in the example below:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Timer</span> <span class="p">{</span>
    <span class="n">callback</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nf">FnOnce</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="p">()</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">Timer</span> <span class="p">{</span>
        <span class="n">callback</span><span class="p">:</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(||</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello from callback"</span><span class="p">)),</span>
    <span class="p">};</span>

    <span class="p">(</span><span class="n">timer</span><span class="py">.callback</span><span class="p">)();</span>

    <span class="k">let</span> <span class="n">timer_repetition</span> <span class="o">=</span> <span class="n">Timer</span> <span class="p">{</span>
        <span class="n">callback</span><span class="p">:</span> <span class="n">timer</span><span class="py">.callback</span><span class="p">,</span> <span class="c1">// error[E0382]: use of moved value: `t.callback`</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="using-a-fn-trait-object-for-the-callback">Using a <code class="language-plaintext highlighter-rouge">Fn</code> trait object for the callback</h3>

<p><code class="language-plaintext highlighter-rouge">Fn</code> is implemented by closures which can be called multiple times, so the following will compile:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Timer</span> <span class="p">{</span>
    <span class="n">callback</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nf">Fn</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="p">()</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">Timer</span> <span class="p">{</span>
        <span class="n">callback</span><span class="p">:</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(||</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello from callback"</span><span class="p">)),</span>
    <span class="p">};</span>

    <span class="p">(</span><span class="n">timer</span><span class="py">.callback</span><span class="p">)();</span>

    <span class="k">let</span> <span class="n">timer_repetition</span> <span class="o">=</span> <span class="n">Timer</span> <span class="p">{</span>
        <span class="n">callback</span><span class="p">:</span> <span class="n">timer</span><span class="py">.callback</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="p">(</span><span class="n">timer_repetition</span><span class="py">.callback</span><span class="p">)();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>But to be able to operate on some state, the closure would need to either capture values from it’s environment or be supplied the state as arguments when executed.</p>

<p><code class="language-plaintext highlighter-rouge">Fn</code> implementing closures can either do one of two things:</p>
<ul>
  <li>don’t move captured values out AND don’t mutate them, or</li>
  <li>capture nothing from their environment.</li>
</ul>

<p>We therefore can’t use state captured from the environment with a <code class="language-plaintext highlighter-rouge">Fn</code> closure, we’ll get an error like that in this example:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Timer</span> <span class="p">{</span>
    <span class="n">callback</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nf">Fn</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="p">()</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">character</span> <span class="o">=</span> <span class="n">Character</span> <span class="p">{</span>
        <span class="n">hitpoints</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">Timer</span> <span class="p">{</span>
        <span class="n">callback</span><span class="p">:</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="n">character</span><span class="py">.hitpoints</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">),</span>
        <span class="c1">// error[E0594]: cannot assign to `character.hitpoints`, as it is</span>
        <span class="c1">// a captured variable in a `Fn` closure</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This leaves passing state as arguments to the <code class="language-plaintext highlighter-rouge">callback</code> closure, which is possible when using a <code class="language-plaintext highlighter-rouge">Fn</code> trait object:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Timer</span> <span class="p">{</span>
    <span class="n">state</span><span class="p">:</span> <span class="n">Character</span><span class="p">,</span>
    <span class="n">callback</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">Character</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">()</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">character</span> <span class="o">=</span> <span class="n">Character</span> <span class="p">{</span>
        <span class="n">hitpoints</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">stamina</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">Timer</span> <span class="p">{</span>
        <span class="n">state</span><span class="p">:</span> <span class="n">character</span><span class="p">,</span>
        <span class="n">callback</span><span class="p">:</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(|</span><span class="n">character</span><span class="p">|</span> <span class="n">character</span><span class="py">.hitpoints</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">state</span> <span class="o">=</span> <span class="n">timer</span><span class="py">.state</span><span class="p">;</span>
    <span class="p">(</span><span class="n">timer</span><span class="py">.callback</span><span class="p">)(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">state</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">timer_repetition</span> <span class="o">=</span> <span class="n">Timer</span> <span class="p">{</span>
        <span class="n">state</span><span class="p">,</span>
        <span class="n">callback</span><span class="p">:</span> <span class="n">timer</span><span class="py">.callback</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">state</span> <span class="o">=</span> <span class="n">timer_repetition</span><span class="py">.state</span><span class="p">;</span>

    <span class="p">(</span><span class="n">timer_repetition</span><span class="py">.callback</span><span class="p">)(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">state</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Each execution of the timer pulls out the <code class="language-plaintext highlighter-rouge">state</code> property from it and passes it to the <code class="language-plaintext highlighter-rouge">callback</code>.</p>

<p>The problem here is that <code class="language-plaintext highlighter-rouge">Timer</code> structs can now only operate on <code class="language-plaintext highlighter-rouge">Character</code> types. I could have multiple <code class="language-plaintext highlighter-rouge">Timer</code> struct definitions, one for each type of state they will operate on e.g. <code class="language-plaintext highlighter-rouge">CharacterTimer</code> but then specifying the types in the logic that creates the timers and executes them would then be very complicated, if not impossible.</p>

<p>I explored an alternative of setting the <code class="language-plaintext highlighter-rouge">state</code> type to be a trait object too:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Timer</span> <span class="p">{</span>
    <span class="n">state</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">State</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">callback</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">State</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">()</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">State</code> trait would categorise a struct that can have some state updated by a callback, for example through an <code class="language-plaintext highlighter-rouge">update</code> method:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="n">State</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">update</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Character</code> would then needed to implement the trait:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">State</span> <span class="k">for</span> <span class="n">Character</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">update</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// update self</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You can’t update state without some extra arguments to <code class="language-plaintext highlighter-rouge">update</code> though. These arguments can’t be specific to the type that implements <code class="language-plaintext highlighter-rouge">State</code>, because then all types implementing <code class="language-plaintext highlighter-rouge">State</code> would need an <code class="language-plaintext highlighter-rouge">update</code> function that takes those arguments:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="n">State</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">update</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">hitpoints</span><span class="p">,</span> <span class="n">stamina</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">();</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">State</span> <span class="k">for</span> <span class="n">Character</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">update</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">hitpoints</span><span class="p">,</span> <span class="n">stamina</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">self</span><span class="py">.hitpoints</span> <span class="o">+=</span> <span class="n">hitpoints</span><span class="p">;</span>
      <span class="k">self</span><span class="py">.stamina</span> <span class="o">+=</span> <span class="n">stamina</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">State</span> <span class="k">for</span> <span class="n">TreasureChest</span> <span class="p">{</span> <span class="c1">// A TreasureChest doesn't have "hitpoints" or "stamina"</span>
    <span class="k">fn</span> <span class="nf">update</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">gold</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// &lt;-- type signature is incompatible with that of State</span>
      <span class="k">self</span><span class="py">.gold</span> <span class="o">+=</span> <span class="n">gold</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Instead, <code class="language-plaintext highlighter-rouge">update</code> could take a more generic argument which provides information on the state property that needs updating and the delta to change it by:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">StateDelta</span> <span class="p">{</span>
    <span class="n">property</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">delta</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">update</code> could then take a vec of these structs:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="n">State</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">update</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">state_deltas</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">StateDelta</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Implementing <code class="language-plaintext highlighter-rouge">State</code> for a <code class="language-plaintext highlighter-rouge">Character</code> would then look like this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">State</span> <span class="k">for</span> <span class="n">Character</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">update</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">state_deltas</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">StateDelta</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">state_delta</span> <span class="k">in</span> <span class="n">state_deltas</span> <span class="p">{</span>
            <span class="k">match</span> <span class="n">state_delta</span><span class="py">.property</span><span class="nf">.as_str</span><span class="p">()</span> <span class="p">{</span>
                <span class="s">"+hitpoints"</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="py">.hitpoints</span> <span class="o">+=</span> <span class="n">state_delta</span><span class="py">.delta</span><span class="p">,</span>
                <span class="s">"-hitpoints"</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="py">.hitpoints</span> <span class="o">-=</span> <span class="n">state_delta</span><span class="py">.delta</span><span class="p">,</span>
                <span class="s">"+stamina"</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="py">.stamina</span> <span class="o">+=</span> <span class="n">state_delta</span><span class="py">.delta</span><span class="p">,</span>
                <span class="s">"-stamina"</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="py">.stamina</span> <span class="o">-=</span> <span class="n">state_delta</span><span class="py">.delta</span><span class="p">,</span>
                <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">(),</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And then setting up the <code class="language-plaintext highlighter-rouge">Timer</code> that modifies the state of a <code class="language-plaintext highlighter-rouge">Character</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">character</span> <span class="o">=</span> <span class="n">Character</span> <span class="p">{</span>
        <span class="n">hitpoints</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">stamina</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">Timer</span> <span class="p">{</span>
        <span class="n">state</span><span class="p">:</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">character</span><span class="p">),</span>
        <span class="n">callback</span><span class="p">:</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(|</span><span class="n">character</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">state_deltas</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span>
                <span class="n">StateDelta</span> <span class="p">{</span>
                    <span class="n">property</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"+hitpoints"</span><span class="p">),</span>
                    <span class="n">delta</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">];</span>
            <span class="n">character</span><span class="nf">.update</span><span class="p">(</span><span class="n">state_deltas</span><span class="p">);</span>
        <span class="p">}),</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">state</span> <span class="o">=</span> <span class="n">timer</span><span class="py">.state</span><span class="p">;</span>
    <span class="p">(</span><span class="n">timer</span><span class="py">.callback</span><span class="p">)(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">state</span><span class="p">);</span>

    <span class="c1">// snip</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This works, but storing the state separately on the <code class="language-plaintext highlighter-rouge">Timer</code> just to be able to pass it as an argument to <code class="language-plaintext highlighter-rouge">callback</code> and so satisfy the <code class="language-plaintext highlighter-rouge">Fn</code> trait seems unnecessary, when we could instead have the closure capture the state from its environment.</p>

<h3 id="using-a-fnmut-trait-object-for-the-callback">Using a <code class="language-plaintext highlighter-rouge">FnMut</code> trait object for the callback</h3>

<p>To allow capturing state from the environment and mutating it, a <code class="language-plaintext highlighter-rouge">FnMut</code> trait object is needed instead:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Timer</span> <span class="p">{</span>
    <span class="n">callback</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nf">FnMut</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="p">()</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The state (a <code class="language-plaintext highlighter-rouge">Character</code> struct in this case) can then be captured by the closure and mutated. But just attempting to mutate the state in the callback after making it a <code class="language-plaintext highlighter-rouge">FnMut</code> trait object won’t work. An error relating to lifetimes will result as in this example:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">character</span> <span class="o">=</span> <span class="n">Character</span> <span class="p">{</span>
        <span class="n">hitpoints</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">Timer</span> <span class="p">{</span>
        <span class="n">callback</span><span class="p">:</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(||</span> <span class="p">{</span>
            <span class="n">character</span><span class="py">.hitpoints</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">;</span>
            <span class="c1">// error[E0597]: `character.hitpoints` does not live long enough</span>

        <span class="p">}),</span>
    <span class="p">};</span>
<span class="p">}</span> <span class="c1">// - `character.hitpoints` dropped here while still borrowed</span>
</code></pre></div></div>

<p>The problem is that the compiler is giving the trait object (<code class="language-plaintext highlighter-rouge">dyn FnMut() -&gt; ()</code>) on the <code class="language-plaintext highlighter-rouge">Timer</code> struct a lifetime of <code class="language-plaintext highlighter-rouge">'static</code>, meaning it treats the lifetime of the callback closure as potentially as long as the program. But the closure captures the <code class="language-plaintext highlighter-rouge">hitpoints</code> property from <code class="language-plaintext highlighter-rouge">Timer</code> using a mutable reference, and that is only valid for the lifetime of the <code class="language-plaintext highlighter-rouge">Timer</code> struct it belongs to. The <code class="language-plaintext highlighter-rouge">Timer</code> struct is dropped at the end of the <code class="language-plaintext highlighter-rouge">main()</code> function and so has a shorter lifetime than <code class="language-plaintext highlighter-rouge">'static</code>. The solution is to provide the compiler more information by specifying a lifetime parameter on <code class="language-plaintext highlighter-rouge">Timer</code> - to tell it that the closure should only have a lifetime equal to that of the <code class="language-plaintext highlighter-rouge">Timer</code> struct it belongs to:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Timer</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">callback</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nf">FnMut</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="p">()</span> <span class="o">+</span> <span class="nv">'a</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now the code compiles and we can run repetitions of the timer too:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">character</span> <span class="o">=</span> <span class="n">Character</span> <span class="p">{</span>
        <span class="n">hitpoints</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">Timer</span> <span class="p">{</span>
        <span class="n">callback</span><span class="p">:</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(||</span> <span class="p">{</span>
            <span class="n">character</span><span class="py">.hitpoints</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="p">}),</span>
    <span class="p">};</span>

    <span class="p">(</span><span class="n">timer</span><span class="py">.callback</span><span class="p">)();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">timer_repetition</span> <span class="o">=</span> <span class="n">Timer</span> <span class="p">{</span>
        <span class="n">callback</span><span class="p">:</span> <span class="n">timer</span><span class="py">.callback</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="p">(</span><span class="n">timer_repetition</span><span class="py">.callback</span><span class="p">)();</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="using-a-function-pointer-for-the-callback">Using a function pointer for the callback</h3>

<p>I explored the alternative of using a function pointer for the callback. A function pointer to a function on a struct can be set as a property on another struct e.g.:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Timer</span> <span class="p">{</span>
    <span class="n">callback</span><span class="p">:</span> <span class="k">fn</span><span class="p">(),</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Character</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="n">Character</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">update</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">Timer</span> <span class="p">{</span>
        <span class="n">callback</span><span class="p">:</span> <span class="nn">Character</span><span class="p">::</span><span class="n">update</span><span class="p">,</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">update()</code> function on Character in the example above does not take any arguments. In reality it would need to take a <code class="language-plaintext highlighter-rouge">self</code> argument so that it could update the <code class="language-plaintext highlighter-rouge">Character</code> instance. Adding a <code class="language-plaintext highlighter-rouge">self</code> parameter to <code class="language-plaintext highlighter-rouge">update()</code> means that the type for <code class="language-plaintext highlighter-rouge">callback</code> on <code class="language-plaintext highlighter-rouge">Timer</code> then needs to reflect that. The state also needs to be added as a property on <code class="language-plaintext highlighter-rouge">Timer</code> so it can be passed to the callback:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Timer</span> <span class="p">{</span>
    <span class="n">callback</span><span class="p">:</span> <span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Character</span><span class="p">),</span>
    <span class="n">state</span><span class="p">:</span> <span class="n">Character</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Character</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="n">Character</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">update</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="k">let</span> <span class="n">character</span> <span class="o">=</span> <span class="n">Character</span> <span class="p">{};</span>

    <span class="k">let</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">Timer</span> <span class="p">{</span>
        <span class="n">callback</span><span class="p">:</span> <span class="nn">Character</span><span class="p">::</span><span class="n">update</span><span class="p">,</span>
        <span class="n">state</span><span class="p">:</span> <span class="n">character</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="p">(</span><span class="n">timer</span><span class="py">.callback</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">timer</span><span class="py">.state</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This compiles but now we have the same issue we saw before when passing state as arguments to a callback closure that implemented the <code class="language-plaintext highlighter-rouge">Fn</code> trait - that <code class="language-plaintext highlighter-rouge">Timer</code> would only work with <code class="language-plaintext highlighter-rouge">Character</code> structs and no other types of state.</p>

<p>To allow <code class="language-plaintext highlighter-rouge">Timer</code> to take callbacks which can operate on different types of state, a trait bound can be specified on <code class="language-plaintext highlighter-rouge">Timer</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="n">State</span> <span class="p">{}</span>

<span class="k">struct</span> <span class="n">Character</span> <span class="p">{}</span>
<span class="k">struct</span> <span class="n">Monster</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="n">State</span> <span class="k">for</span> <span class="n">Character</span> <span class="p">{}</span>
<span class="k">impl</span> <span class="n">State</span> <span class="k">for</span> <span class="n">Monster</span> <span class="p">{}</span>

<span class="k">struct</span> <span class="n">Timer</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">State</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">state</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">callback</span><span class="p">:</span> <span class="k">fn</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Character</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">update</span><span class="p">(</span><span class="k">self</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Monster</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">update</span><span class="p">(</span><span class="k">self</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">character</span> <span class="o">=</span> <span class="n">Character</span> <span class="p">{};</span>

    <span class="k">let</span> <span class="n">character_timer</span> <span class="o">=</span> <span class="n">Timer</span> <span class="p">{</span>
        <span class="n">state</span><span class="p">:</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">character</span><span class="p">),</span>
        <span class="n">callback</span><span class="p">:</span> <span class="nn">Character</span><span class="p">::</span><span class="n">update</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="p">(</span><span class="n">character_timer</span><span class="py">.callback</span><span class="p">)(</span><span class="n">character_timer</span><span class="py">.state</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">monster_timer</span> <span class="o">=</span> <span class="n">Timer</span> <span class="p">{</span>
        <span class="n">state</span><span class="p">:</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">monster</span><span class="p">),</span>
        <span class="n">callback</span><span class="p">:</span> <span class="nn">Monster</span><span class="p">::</span><span class="n">update</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="p">(</span><span class="n">monster_timer</span><span class="py">.callback</span><span class="p">)(</span><span class="n">monster_timer</span><span class="py">.state</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Using <code class="language-plaintext highlighter-rouge">T: State</code> specifies that both the <code class="language-plaintext highlighter-rouge">state</code> and <code class="language-plaintext highlighter-rouge">callback</code> properties on <code class="language-plaintext highlighter-rouge">Timer</code> need to take a type that implements the <code class="language-plaintext highlighter-rouge">State</code> trait. Importantly it also means that for any particular instance of a <code class="language-plaintext highlighter-rouge">Timer</code>, the <em>concrete type</em> these two properties take must be the same i.e. you can’t set up a <code class="language-plaintext highlighter-rouge">Timer</code> with a <code class="language-plaintext highlighter-rouge">Monster</code> for state but <code class="language-plaintext highlighter-rouge">Character::update</code> as the callback. It ensures that whatever concrete type is set for <code class="language-plaintext highlighter-rouge">state</code> must also be the concrete type that <code class="language-plaintext highlighter-rouge">callback</code> accepts as an argument:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="n">character</span> <span class="o">=</span> <span class="n">Character</span> <span class="p">{</span> <span class="n">hitpoints</span><span class="p">:</span> <span class="mi">100</span> <span class="p">};</span>

    <span class="k">let</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">Timer</span> <span class="p">{</span>
        <span class="n">state</span><span class="p">:</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">character</span><span class="p">),</span>
        <span class="n">callback</span><span class="p">:</span> <span class="nn">Monster</span><span class="p">::</span><span class="n">update</span><span class="p">,</span>
        <span class="c1">// error[E0308]: mismatched types</span>
        <span class="c1">// = note: expected fn pointer `fn(Box&lt;Character&gt;)`</span>
        <span class="c1">//   found fn item `fn(Box&lt;Monster&gt;) {Monster::update}`</span>
    <span class="p">};</span>
</code></pre></div></div>

<p>Now we have the ability to pass the state instance to the callback and the callback can modify it. But we need to pass additional arguments so the callback knows <em>how</em> to modify the state, e.g. the integer amount to increase a character’s hitpoints by. The same approach as we took before with the <code class="language-plaintext highlighter-rouge">Fn</code> trait closure can be taken here - introducing a <code class="language-plaintext highlighter-rouge">StateDelta</code> type:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">StateDelta</span> <span class="p">{</span>
    <span class="n">property</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">delta</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Timer</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">State</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// snip</span>
    <span class="n">callback</span><span class="p">:</span> <span class="k">fn</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">StateDelta</span><span class="o">&gt;</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Character</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">update</span><span class="p">(</span><span class="k">self</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">state_deltas</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">StateDelta</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// snip</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">character</span> <span class="o">=</span> <span class="n">Character</span> <span class="p">{};</span>

    <span class="k">let</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">Timer</span> <span class="p">{</span>
        <span class="n">state</span><span class="p">:</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">character</span><span class="p">),</span>
        <span class="n">callback</span><span class="p">:</span> <span class="nn">Character</span><span class="p">::</span><span class="n">update</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="n">state_deltas</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span>
        <span class="n">StateDelta</span> <span class="p">{</span>
            <span class="n">property</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"+hitpoints"</span><span class="p">),</span>
            <span class="n">delta</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">];</span>

    <span class="p">(</span><span class="n">timer</span><span class="py">.callback</span><span class="p">)(</span><span class="n">timer</span><span class="py">.state</span><span class="p">,</span> <span class="n">state_deltas</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>One thing to note here - <code class="language-plaintext highlighter-rouge">StateDelta</code> only allows a <code class="language-plaintext highlighter-rouge">u8</code> type for the <code class="language-plaintext highlighter-rouge">delta</code> property. This only allows passing numeric deltas, but what if the state needs a <code class="language-plaintext highlighter-rouge">String</code> property updating? A string could be represented as an integer which would then need to be converted back to a string by the <code class="language-plaintext highlighter-rouge">update()</code> method on the state type, but I’m unsure if that will be true for all the different types that need to be updated on state types, because I’m not sure what they all are yet. I’ll revisit this later, if I decide to take this approach.</p>

<h3 id="wrap-up">Wrap up</h3>

<p>I’m not 100% sure which of the above approaches is best at this point.</p>

<p>In my next journal post I’ll explore passing the <code class="language-plaintext highlighter-rouge">Timer</code> struct between threads, since adding the callback property as in the code above will not compile at the moment when multiple threads are involved.</p>

<p>I’ll then explore how the state that is mutated by the callback can be used from elsewhere in the code in between calls to the callback, which isn’t possible with the code above since ownership of the state is either taken by the closure and not given back, or needs to be transferred back and forth between the closure and the execution thread on each repetition.</p>

<p>Allowing the state to be used by other code in between timer executions (and after the final execution) will be necessary. As an example: given a timer that increments <code class="language-plaintext highlighter-rouge">hitpoints</code> every few seconds, the updated hitpoints will need to be sent back to the game client after each execution so the client can display the correct hitpoints. Some mechanism is needed to allow ownership to be transferred elsewhere in between timer executions.</p>

<p>Exploring different approaches to solving these two issues next should guide me towards the best approach.</p>

  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">this.rob.journal</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li><a href="mailto:this.rob@protonmail.com">this.rob@protonmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/thisdotrob"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">thisdotrob</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/thisdotrob"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">thisdotrob</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>A place to document and share my explorations in coding. Mainly so I can go back and copy paste when I forget how to do something ;)
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>

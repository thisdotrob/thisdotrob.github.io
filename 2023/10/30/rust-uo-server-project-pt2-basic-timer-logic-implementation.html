<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Rust UO server project pt2: Basic Timer Logic Implementation</title>
  <meta name="description" content="I’ve finished v1 of the Rust UO server timer logic. The logic covers:  registering new timers  calculating their next run time  checking registered timers fo...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://yourdomain.com/2023/10/30/rust-uo-server-project-pt2-basic-timer-logic-implementation.html">
  <link rel="alternate" type="application/rss+xml" title="this.rob.journal" href="http://yourdomain.com/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">this.rob.journal</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
          <a class="page-link" href="/about">About</a>
          <a class="page-link" href="/tags">Tags</a>
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Rust UO server project pt2: Basic Timer Logic Implementation</h1>
    <p class="post-meta"><time datetime="2023-10-30T17:00:00+00:00" itemprop="datePublished">Oct 30, 2023</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>I’ve finished v1 of the Rust UO server timer logic. The logic covers:</p>
<ul>
  <li>registering new timers</li>
  <li>calculating their next run time</li>
  <li>checking registered timers for those due to be run</li>
  <li>removing timers that are due to be run and “running” them</li>
  <li>re-registering timers for next repetitions</li>
</ul>

<p>At the moment there are no callbacks attached to the timers so when they are “run” nothing actually happens beyond dequeing the timer (and re-registering a repeat of it if there are repetitions remaining).</p>

<p>To test the logic I added a CLI module which allows starting timers from the command line and monitoring their repetitions being “run” via progress bars:</p>

<p><img src="/assets/rust_uo_server_timer_logic_v1_demo.gif" alt="rust_uo_server_timer_logic_v1_demo.gif" /></p>

<h3 id="code-walkthrough">Code walkthrough</h3>

<h4 id="timer-structs">Timer structs</h4>

<p>First I created the <code class="language-plaintext highlighter-rouge">Timer</code> struct in a new <em>timer</em> module:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/timer.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Timer</span> <span class="p">{</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">repetitions</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
    <span class="n">interval</span><span class="p">:</span> <span class="nb">i64</span><span class="p">,</span>
    <span class="n">next</span><span class="p">:</span> <span class="nb">i64</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">repetitions</code> are the number of repetitions of the timer left to run. <code class="language-plaintext highlighter-rouge">interval</code> is the time in ms between each repetition. <code class="language-plaintext highlighter-rouge">next</code> is the next server tick that the timer is due to run at.</p>

<p><code class="language-plaintext highlighter-rouge">next</code> will be calculated by the server: when a timer is registered for the first time it will be <em>current ticks + timer interval</em>. When timer repetitions are registered it will be calculated as <em>previous next + interval</em>.</p>

<p>Because <code class="language-plaintext highlighter-rouge">next</code> will be calculated by the server as above, it won’t be provided to the registration logic when code elsewhere requests a timer be registered for the first time. I therefore created a second <code class="language-plaintext highlighter-rouge">TimerArgs</code> struct to represent the subset of timer properties that <em>will</em> be provided to the registration thread by code elsewhere:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/timer.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">TimerArgs</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">repetitions</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">interval</span><span class="p">:</span> <span class="nb">i64</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In the future this will also allow properties to be optional when passed to the thread, with the thread then being responsible for setting defaults e.g. <code class="language-plaintext highlighter-rouge">TimerArgs</code> provided with <code class="language-plaintext highlighter-rouge">Option::None</code> for <code class="language-plaintext highlighter-rouge">repetitions</code> would have <code class="language-plaintext highlighter-rouge">repetitions</code> set to 1 when the <code class="language-plaintext highlighter-rouge">Timer</code> struct was created by the registration thread.</p>

<h4 id="server-ticks">Server ticks</h4>

<p>Knowing that calculating <code class="language-plaintext highlighter-rouge">next</code> for a timer required the current server ticks, I next set up a function to return them:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/timer.rs</span>
<span class="k">use</span> <span class="nn">chrono</span><span class="p">::</span><span class="nn">prelude</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">current_ticks</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i64</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">utc_now</span> <span class="o">=</span> <span class="nn">Utc</span><span class="p">::</span><span class="nf">now</span><span class="p">();</span>
    <span class="n">utc_now</span><span class="nf">.timestamp_millis</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I opted to go with a tick equalling a millisecond to begin with, but the resolution will need to be increased later.</p>

<h4 id="registration-thread">Registration thread</h4>

<p>Next I set up the registration thread:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/timer.rs</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::{</span><span class="nb">Arc</span><span class="p">,</span> <span class="n">Mutex</span><span class="p">,</span> <span class="n">mpsc</span><span class="p">};</span>

<span class="k">mod</span> <span class="n">registration_thread</span><span class="p">;</span>

<span class="c1">// snip</span>

<span class="k">fn</span> <span class="nf">start</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">mpsc</span><span class="p">::</span><span class="n">Sender</span><span class="o">&lt;</span><span class="n">TimerArgs</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">register_tx</span><span class="p">,</span> <span class="n">register_rx</span><span class="p">)</span> <span class="o">=</span> <span class="nn">mpsc</span><span class="p">::</span><span class="nn">channel</span><span class="p">::</span><span class="o">&lt;</span><span class="n">TimerArgs</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">new_timers</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Timer</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
    <span class="k">let</span> <span class="n">new_timers</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Mutex</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">new_timers</span><span class="p">));</span>

    <span class="nn">registration_thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="n">register_rx</span><span class="p">,</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_timers</span><span class="p">));</span>

    <span class="k">return</span> <span class="n">register_tx</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In the <em>timer</em> module I added a <code class="language-plaintext highlighter-rouge">start()</code> function which will be called by <code class="language-plaintext highlighter-rouge">main()</code> in <code class="language-plaintext highlighter-rouge">src/main.rs</code>. This function returns an mpsc transmitter which the <code class="language-plaintext highlighter-rouge">main()</code> function will use to send <code class="language-plaintext highlighter-rouge">TimerArgs</code> to the registration thread. In the future it won’t be <code class="language-plaintext highlighter-rouge">main()</code> that uses this transmitter, but other parts of the code responsible for requesting timer registration.</p>

<p>The <code class="language-plaintext highlighter-rouge">start()</code> function also sets up a <code class="language-plaintext highlighter-rouge">new_timers</code> vec. Ownership of this vec will be shared between the registration thread and the prioritisation thread. The registration thread will push new timers into it, the prioritisation thread will remove them from it and prioritise them. To allow shared ownership, the vec is wrapped in a <code class="language-plaintext highlighter-rouge">Mutex</code> to allow each thread to modify it after acquiring a lock. Because the mutex needs to be passed to two threads, it is wrapped in an <code class="language-plaintext highlighter-rouge">Arc</code>.</p>

<p><code class="language-plaintext highlighter-rouge">start()</code> calls the <code class="language-plaintext highlighter-rouge">spawn()</code> function from the <em>registration_thread</em> submodule, passing it the mpsc receiver so it can receive <code class="language-plaintext highlighter-rouge">TimerArgs</code> and the wrapped <code class="language-plaintext highlighter-rouge">new_timers</code> vec, so it can add <code class="language-plaintext highlighter-rouge">Timers</code> to it.</p>

<p>The <code class="language-plaintext highlighter-rouge">spawn()</code> function was declared in <code class="language-plaintext highlighter-rouge">src/timer/registration_thread.rs</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/timer/registration_thread.rs</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::{</span><span class="nb">Arc</span><span class="p">,</span> <span class="n">Mutex</span><span class="p">,</span> <span class="n">mpsc</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">thread</span><span class="p">;</span>
<span class="k">use</span> <span class="k">super</span><span class="p">::{</span><span class="n">Timer</span><span class="p">,</span> <span class="n">TimerArgs</span><span class="p">,</span> <span class="n">current_ticks</span><span class="p">};</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">spawn</span><span class="p">(</span><span class="n">register_rx</span><span class="p">:</span> <span class="nn">mpsc</span><span class="p">::</span><span class="n">Receiver</span><span class="o">&lt;</span><span class="n">TimerArgs</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">new_timers</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Timer</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">timer_args</span> <span class="k">in</span> <span class="n">register_rx</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">TimerArgs</span> <span class="p">{</span> <span class="n">name</span><span class="p">,</span> <span class="n">repetitions</span><span class="p">,</span> <span class="n">interval</span> <span class="p">}</span> <span class="o">=</span> <span class="n">timer_args</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">next</span> <span class="o">=</span> <span class="nf">current_ticks</span><span class="p">()</span> <span class="o">+</span> <span class="n">interval</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">Timer</span> <span class="p">{</span> <span class="n">name</span><span class="p">,</span> <span class="n">repetitions</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">next</span> <span class="p">};</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">new_timers</span> <span class="o">=</span> <span class="n">new_timers</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="n">new_timers</span><span class="nf">.push</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">spawn()</code> moves the register receiver and the <code class="language-plaintext highlighter-rouge">Arc&lt;Mutex&lt;&gt;&gt;</code> new_timers into a newly spawned thread. It treats the register receiver as an iterator by using a for loop on it. This executes the for loop block each time <code class="language-plaintext highlighter-rouge">TimerArgs</code> are sent to the mpsc channel.</p>

<p>When <code class="language-plaintext highlighter-rouge">TimerArgs</code> are received, the thread calculates <code class="language-plaintext highlighter-rouge">next</code>, constructs a <code class="language-plaintext highlighter-rouge">Timer</code> struct using it and other properties from <code class="language-plaintext highlighter-rouge">TimerArgs</code> and then pushes it into <code class="language-plaintext highlighter-rouge">new_timers</code> after acquiring a lock.</p>

<p>At the moment I’ve left the <code class="language-plaintext highlighter-rouge">unwrap()</code> call when acquiring the lock. This will need to be replaced with better error handling in the future.</p>

<h4 id="prioritisation-thread">Prioritisation thread</h4>

<p>Next I set up the thread that will periodically check the <code class="language-plaintext highlighter-rouge">new_timers</code> vec under lock and prioritise the <code class="language-plaintext highlighter-rouge">Timer</code> structs it finds there:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/timer.rs</span>

<span class="k">mod</span> <span class="n">prioritisation_thread</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">start</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">mpsc</span><span class="p">::</span><span class="n">Sender</span><span class="o">&lt;</span><span class="n">TimerArgs</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// snip</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">execute_tx</span><span class="p">,</span> <span class="n">execute_rx</span><span class="p">)</span> <span class="o">=</span> <span class="nn">mpsc</span><span class="p">::</span><span class="nn">channel</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Timer</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">new_timers</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Timer</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
    <span class="k">let</span> <span class="n">new_timers</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Mutex</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">new_timers</span><span class="p">));</span>

    <span class="c1">// snip</span>

    <span class="nn">prioritisation_thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="n">execute_tx</span><span class="p">,</span> <span class="n">new_timers</span><span class="p">);</span>

    <span class="c1">// snip</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Similar to with the registration thread setup, <code class="language-plaintext highlighter-rouge">start()</code> now also calls the <code class="language-plaintext highlighter-rouge">spawn()</code> function from the <em>prioritisation_thread</em> submodule. It passes it an mpsc transmitter the prioritisation thread will use to send timers to be executed. It also passes the wrapped <code class="language-plaintext highlighter-rouge">new_timers</code> vec, so the prioritisation thread can pull <code class="language-plaintext highlighter-rouge">Timer</code> structs from it and prioritise them.</p>

<p>Nothing is done with the corresponding mpsc receiver yet - this will be given to the execution thread so it can receive the <code class="language-plaintext highlighter-rouge">Timer</code> structs to be executed.</p>

<p>The new <code class="language-plaintext highlighter-rouge">spawn()</code> function was declared in <code class="language-plaintext highlighter-rouge">src/timer/prioritisation_thread.rs</code>. Like the <code class="language-plaintext highlighter-rouge">spawn()</code> function in the registration thread module it spawns a new thread:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/timer/prioritisation_thread.rs</span>
<span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="n">Timer</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::{</span><span class="nb">Arc</span><span class="p">,</span> <span class="n">Mutex</span><span class="p">,</span> <span class="n">mpsc</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">thread</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">spawn</span><span class="p">(</span><span class="n">execute_tx</span><span class="p">:</span> <span class="nn">mpsc</span><span class="p">::</span><span class="n">Sender</span><span class="o">&lt;</span><span class="n">Timer</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">new_timers</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Timer</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In the new thread, I first implemented acquiring a lock on <code class="language-plaintext highlighter-rouge">new_timers</code> every millisecond and emptying it into a new vec that is owned solely by the thread:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/timer/prioritisation_thread.rs</span>

<span class="c1">// snip</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">spawn</span><span class="p">(</span><span class="n">execute_tx</span><span class="p">:</span> <span class="nn">mpsc</span><span class="p">::</span><span class="n">Sender</span><span class="o">&lt;</span><span class="n">Timer</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">new_timers</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Timer</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">timers</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">loop</span> <span class="p">{</span>
            <span class="nn">thread</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
            <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">new_timers</span> <span class="o">=</span> <span class="n">new_timers</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">timer</span><span class="p">)</span> <span class="o">=</span> <span class="n">new_timers</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
                    <span class="n">timers</span><span class="nf">.push</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This means that the thread only locks <code class="language-plaintext highlighter-rouge">new_timers</code> once a millisecond and only for as long as it takes to remove all elements from it and push them to the new vec. This minimises the time that the registration thread is unable to acquire a lock and so can’t process timer registrations.</p>

<p>Next I added logic to go through the <code class="language-plaintext highlighter-rouge">timers</code> vec and send any that are due to be run to the channel transmitter for the execution thread to pick up:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/timer/prioritisation_thread.rs</span>
<span class="k">use</span> <span class="k">super</span><span class="p">::{</span><span class="n">Timer</span><span class="p">,</span> <span class="n">current_ticks</span><span class="p">};</span>

<span class="c1">// snip</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">spawn</span><span class="p">(</span><span class="n">execute_tx</span><span class="p">:</span> <span class="nn">mpsc</span><span class="p">::</span><span class="n">Sender</span><span class="o">&lt;</span><span class="n">Timer</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">new_timers</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Timer</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">timers</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">loop</span> <span class="p">{</span>
            <span class="c1">// snip</span>

            <span class="k">let</span> <span class="n">now</span> <span class="o">=</span> <span class="nf">current_ticks</span><span class="p">();</span>

            <span class="k">for</span> <span class="n">timer</span> <span class="k">in</span> <span class="n">timers</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">timer</span><span class="py">.next</span> <span class="o">&lt;=</span> <span class="n">now</span> <span class="p">{</span>
                    <span class="n">execute_tx</span><span class="nf">.send</span><span class="p">(</span><span class="n">timer</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This won’t compile because after the first iteration of the outer loop the <code class="language-plaintext highlighter-rouge">timers</code> vec has been moved by the for loop and the variable is invalid. <code class="language-plaintext highlighter-rouge">timers</code> needs to be reset at the end of the outer loop:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/timer/prioritisation_thread.rs</span>

<span class="c1">// snip</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">spawn</span><span class="p">(</span><span class="n">execute_tx</span><span class="p">:</span> <span class="nn">mpsc</span><span class="p">::</span><span class="n">Sender</span><span class="o">&lt;</span><span class="n">Timer</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">new_timers</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Timer</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">timers</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">loop</span> <span class="p">{</span>
            <span class="c1">// snip</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">not_due</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

            <span class="k">let</span> <span class="n">now</span> <span class="o">=</span> <span class="nf">current_ticks</span><span class="p">();</span>

            <span class="k">for</span> <span class="n">timer</span> <span class="k">in</span> <span class="n">timers</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">timer</span><span class="py">.next</span> <span class="o">&lt;=</span> <span class="n">now</span> <span class="p">{</span>
                    <span class="n">execute_tx</span><span class="nf">.send</span><span class="p">(</span><span class="n">timer</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">not_due</span><span class="nf">.push</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">timers</span> <span class="o">=</span> <span class="n">not_due</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The last thing needed was to schedule repetitions of timers that had been sent for execution:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/timer/prioritisation_thread.rs</span>

<span class="c1">// snip</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">spawn</span><span class="p">(</span><span class="n">execute_tx</span><span class="p">:</span> <span class="nn">mpsc</span><span class="p">::</span><span class="n">Sender</span><span class="o">&lt;</span><span class="n">Timer</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">new_timers</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Timer</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">timers</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">loop</span> <span class="p">{</span>
            <span class="c1">// snip</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">not_due</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

            <span class="k">let</span> <span class="n">now</span> <span class="o">=</span> <span class="nf">current_ticks</span><span class="p">();</span>

            <span class="k">for</span> <span class="n">timer</span> <span class="k">in</span> <span class="n">timers</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">timer</span><span class="py">.next</span> <span class="o">&lt;=</span> <span class="n">now</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="n">timer</span><span class="py">.repetitions</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                        <span class="k">let</span> <span class="n">next_repetition</span> <span class="o">=</span> <span class="n">Timer</span> <span class="p">{</span>
                            <span class="n">name</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="py">.name</span><span class="p">),</span>
                            <span class="n">repetitions</span><span class="p">:</span> <span class="n">timer</span><span class="py">.repetitions</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                            <span class="n">interval</span><span class="p">:</span> <span class="n">timer</span><span class="py">.interval</span><span class="p">,</span>
                            <span class="n">next</span><span class="p">:</span> <span class="n">timer</span><span class="py">.next</span> <span class="o">+</span> <span class="n">timer</span><span class="py">.interval</span><span class="p">,</span>
                        <span class="p">};</span>
                        <span class="n">not_due</span><span class="nf">.push</span><span class="p">(</span><span class="n">next_repetition</span><span class="p">);</span>
                    <span class="p">}</span>

                    <span class="c1">// snip</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="c1">// snip</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">timers</span> <span class="o">=</span> <span class="n">not_due</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now new <code class="language-plaintext highlighter-rouge">Timer</code> structs are constructed for repetitions, with the <code class="language-plaintext highlighter-rouge">repetitions</code> property decremented and <code class="language-plaintext highlighter-rouge">next</code> incremented by the <code class="language-plaintext highlighter-rouge">interval</code>. The repetition instances are also pushed to the <code class="language-plaintext highlighter-rouge">not_due</code> vec which is then used as the <code class="language-plaintext highlighter-rouge">timers</code> vec for the next iteration of the outer loop.</p>

<p>See the bottom of this post for the finished code.</p>

<h4 id="execution-thread">Execution thread</h4>

<p>The execution thread follows the same module pattern to the other two timer threads:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/timer.rs</span>

<span class="k">mod</span> <span class="n">execution_thread</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">start</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">mpsc</span><span class="p">::</span><span class="n">Sender</span><span class="o">&lt;</span><span class="n">TimerArgs</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// snip</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">execute_tx</span><span class="p">,</span> <span class="n">execute_rx</span><span class="p">)</span> <span class="o">=</span> <span class="nn">mpsc</span><span class="p">::</span><span class="nn">channel</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Timer</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="nn">execution_thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="n">execute_rx</span><span class="p">);</span>

    <span class="c1">// snip</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/timer/execution_thread.rs</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::{</span><span class="nb">Arc</span><span class="p">,</span> <span class="n">Mutex</span><span class="p">,</span> <span class="n">mpsc</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">thread</span><span class="p">;</span>
<span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="n">Timer</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">spawn</span><span class="p">(</span><span class="n">execute_rx</span><span class="p">:</span> <span class="nn">mpsc</span><span class="p">::</span><span class="n">Receiver</span><span class="o">&lt;</span><span class="n">Timer</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">timer</span> <span class="k">in</span> <span class="n">execute_rx</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">timer</span><span class="py">.name</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The execution thread module spawns a new thread, moves the execute receiver into it, treats it as an iterator and prints the name of each <code class="language-plaintext highlighter-rouge">Timer</code> received. In the future it will call a callback on each <code class="language-plaintext highlighter-rouge">Timer</code>.</p>

<h4 id="starting-the-threads-from-mainrs">Starting the threads from <code class="language-plaintext highlighter-rouge">main.rs</code></h4>

<p>At the moment nothing happens when the program runs because the <code class="language-plaintext highlighter-rouge">main()</code> is empty. Next I updated it to call the <code class="language-plaintext highlighter-rouge">start()</code> function from the <em>timer</em> module:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/main.rs</span>
<span class="k">mod</span> <span class="n">timer</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">timer_register_tx</span> <span class="o">=</span> <span class="nn">timer</span><span class="p">::</span><span class="nf">start</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So far so good, but nothing happens when the program runs because nothing is sending <code class="language-plaintext highlighter-rouge">TimerArgs</code> to the registration thread. I hardcoded this in the <code class="language-plaintext highlighter-rouge">main()</code> function to test it worked:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/main.rs</span>
<span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="nn">timer</span><span class="p">::</span><span class="n">TimerArgs</span><span class="p">;</span>

<span class="c1">// snip</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">timer_register_tx</span> <span class="o">=</span> <span class="nn">timer</span><span class="p">::</span><span class="nf">start</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">timer_args</span> <span class="o">=</span> <span class="n">TimerArgs</span> <span class="p">{</span>
        <span class="n">name</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"A Timer!"</span><span class="p">),</span> <span class="n">repetitions</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">interval</span><span class="p">:</span> <span class="mi">50</span>
    <span class="p">};</span>

    <span class="n">timer_register_tx</span><span class="nf">.send</span><span class="p">(</span><span class="n">timer_args</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="creating-timers-from-the-command-line">Creating timers from the command line</h4>

<p>The code written so far isn’t much good with only a single hard coded timer being registered. Next I updated the code to allow starting timers from the command line as the program is running:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/main.rs</span>
<span class="k">mod</span> <span class="n">timer</span><span class="p">;</span>
<span class="k">mod</span> <span class="n">cli</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">timer_register_tx</span> <span class="o">=</span> <span class="nn">timer</span><span class="p">::</span><span class="nf">start</span><span class="p">();</span>
    <span class="nn">cli</span><span class="p">::</span><span class="nf">start</span><span class="p">(</span><span class="n">timer_register_tx</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">main()</code> now calls a <code class="language-plaintext highlighter-rouge">start()</code> function from a new <em>cli</em> module:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/cli.rs</span>
<span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="nn">timer</span><span class="p">::</span><span class="n">TimerArgs</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">io</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="n">mpsc</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">start</span><span class="p">(</span><span class="n">timer_register_tx</span><span class="p">:</span> <span class="nn">mpsc</span><span class="p">::</span><span class="n">Sender</span><span class="o">&lt;</span><span class="n">TimerArgs</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Provide stdin with a string in the following format to register a new timer:"</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"name repetitions interval(ms)"</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"e.g.: </span><span class="se">\"</span><span class="s">timer0 100 50</span><span class="se">\"</span><span class="s">"</span><span class="p">);</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">input</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">()</span><span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">input</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">split_input</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.split_whitespace</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">name</span> <span class="o">=</span> <span class="n">split_input</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">repetitions</span> <span class="o">=</span> <span class="n">split_input</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">repetitions</span><span class="p">:</span> <span class="nb">isize</span> <span class="o">=</span> <span class="n">repetitions</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"Failed to parse numeric string"</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">interval</span> <span class="o">=</span> <span class="n">split_input</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">interval</span><span class="p">:</span> <span class="nb">i64</span> <span class="o">=</span> <span class="n">interval</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"Failed to parse numeric string"</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">timer_args</span> <span class="o">=</span> <span class="n">TimerArgs</span> <span class="p">{</span>
            <span class="n">name</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">repetitions</span><span class="p">,</span> <span class="n">interval</span>
        <span class="p">};</span>

        <span class="n">timer_register_tx</span><span class="nf">.send</span><span class="p">(</span><span class="n">timer_args</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <em>cli</em> module’s <code class="language-plaintext highlighter-rouge">start()</code> function starts a loop which waits for input from stdin. On the command line I could now enter arguments for a new timer in a space separated format of “name repetitions interval” (e.g. <code class="language-plaintext highlighter-rouge">timer0 1000 50</code>) and the module will parse the string, construct <code class="language-plaintext highlighter-rouge">TimerArgs</code> and send them to the registration thread.</p>

<h4 id="progress-bars">Progress bars</h4>

<p>The last change I made wasn’t strictly necessary but the <code class="language-plaintext highlighter-rouge">println!</code> of each timer’s name when it was executied was bugging me because it would get in the way of trying to enter another timer on the command line. I decided it would be fun to display progress bars instead so went ahead and opened up that can of worms.</p>

<p>I pulled in the <a href="https://github.com/console-rs/indicatif">indicatif</a> library and used it in the timer <em>execution thread</em> module to display a progress bar for each timer created and increment them on each repetition:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// src/timer/execution_thread.rs</span>
<span class="k">use</span> <span class="nn">indicatif</span><span class="p">::{</span><span class="n">MultiProgress</span><span class="p">,</span> <span class="n">ProgressBar</span><span class="p">,</span> <span class="n">ProgressStyle</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">;</span>
<span class="c1">// snip</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">spawn</span><span class="p">(</span><span class="n">execute_rx</span><span class="p">:</span> <span class="nn">mpsc</span><span class="p">::</span><span class="n">Receiver</span><span class="o">&lt;</span><span class="n">Timer</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">progress_bars</span> <span class="o">=</span> <span class="nn">MultiProgress</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">sty</span> <span class="o">=</span> <span class="nn">ProgressStyle</span><span class="p">::</span><span class="nf">with_template</span><span class="p">(</span>
            <span class="s">"[{elapsed_precise}] {bar:40.cyan/blue} {pos:&gt;7}/{len:7} {msg}"</span><span class="p">,</span>
        <span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.progress_chars</span><span class="p">(</span><span class="s">"##-"</span><span class="p">);</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">progress_bars_lookup</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="n">ProgressBar</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="k">for</span> <span class="n">timer</span> <span class="k">in</span> <span class="n">execute_rx</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">progress_bar</span> <span class="o">=</span> <span class="n">progress_bars_lookup</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="py">.name</span><span class="p">);</span>
            <span class="k">match</span> <span class="n">progress_bar</span> <span class="p">{</span>
                <span class="nf">Some</span><span class="p">(</span><span class="n">pb</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">pb</span><span class="nf">.inc</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">total</span><span class="p">:</span> <span class="nb">u64</span> <span class="o">=</span> <span class="n">timer</span><span class="py">.repetitions</span><span class="nf">.try_into</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                    <span class="k">let</span> <span class="n">pb</span> <span class="o">=</span> <span class="n">progress_bars</span><span class="nf">.add</span><span class="p">(</span><span class="nn">ProgressBar</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">total</span><span class="p">));</span>
                    <span class="n">pb</span><span class="nf">.set_style</span><span class="p">(</span><span class="n">sty</span><span class="nf">.clone</span><span class="p">());</span>
                    <span class="n">pb</span><span class="nf">.set_message</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="py">.name</span><span class="p">));</span>
                    <span class="n">pb</span><span class="nf">.inc</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
                    <span class="n">progress_bars_lookup</span><span class="nf">.insert</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="py">.name</span><span class="p">),</span> <span class="n">pb</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Instead of printing the timer’s name on execution, the thread now tries to find an existing progress bar for the timer’s name from a hash map and increments it if one is found. If one doesn’t exist, it is created and added to the hash map.</p>

<p>This worked okay, but whenever the progress bars were incremented it would still disrupt the input of a new timer on the command line. I found that indicatif provided a <code class="language-plaintext highlighter-rouge">suspend()</code> method that could be called to temporarily pause the display of the progress bars. The method needed to be called on <code class="language-plaintext highlighter-rouge">progress_bars</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">progress_bars</span> <span class="o">=</span> <span class="nn">MultiProgress</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

<span class="c1">// ...</span>

<span class="n">progress_bars</span><span class="nf">.suspend</span><span class="p">(||</span> <span class="p">{</span>
    <span class="c1">// do something</span>
<span class="p">});</span>

<span class="c1">// progress bars reappear</span>
</code></pre></div></div>

<p>The problem here is that the progress bars were created in the execution thread, but it would be the <em>cli</em> module (running in the main thread) that would know when the progress bars needed to be suspended. The <code class="language-plaintext highlighter-rouge">progress_bars</code> needed to have ownership shared between the main thread and the execution thread - the main thread so it could suspend them and the execution thread so it could create new bars and increment them.</p>

<p>I did the quickest thing I could think of and moved creation of <code class="language-plaintext highlighter-rouge">progress_bars</code> into the <code class="language-plaintext highlighter-rouge">main()</code> function and wrapped it in <code class="language-plaintext highlighter-rouge">Arc</code> and <code class="language-plaintext highlighter-rouge">Mutex</code> before giving it to both the execution thread and the cli module:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/main.rs</span>
<span class="k">use</span> <span class="nn">indicatif</span><span class="p">::</span><span class="n">MultiProgress</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::{</span><span class="nb">Arc</span><span class="p">,</span> <span class="n">Mutex</span><span class="p">};</span>

<span class="k">mod</span> <span class="n">timer</span><span class="p">;</span>
<span class="k">mod</span> <span class="n">cli</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">progress_bars</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Mutex</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">MultiProgress</span><span class="p">::</span><span class="nf">new</span><span class="p">()));</span>

    <span class="k">let</span> <span class="n">timer_register_tx</span> <span class="o">=</span> <span class="nn">timer</span><span class="p">::</span><span class="nf">start</span><span class="p">(</span><span class="nn">Arc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">progress_bars</span><span class="p">));</span>

    <span class="nn">cli</span><span class="p">::</span><span class="nf">start</span><span class="p">(</span><span class="n">progress_bars</span><span class="p">,</span> <span class="n">timer_register_tx</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/timer.rs</span>

<span class="c1">// snip</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">start</span><span class="p">(</span><span class="n">progress_bars</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">MultiProgress</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">mpsc</span><span class="p">::</span><span class="n">Sender</span><span class="o">&lt;</span><span class="n">TimerArgs</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// snip</span>

    <span class="nn">execution_thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="n">execute_rx</span><span class="p">,</span> <span class="n">progress_bars</span><span class="p">);</span>

    <span class="c1">// snip</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/timer/execution_thread.rs</span>

<span class="c1">// snip</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">spawn</span><span class="p">(</span><span class="n">execute_rx</span><span class="p">:</span> <span class="nn">mpsc</span><span class="p">::</span><span class="n">Receiver</span><span class="o">&lt;</span><span class="n">Timer</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">progress_bars</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">MultiProgress</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="c1">// snip</span>

        <span class="k">for</span> <span class="n">timer</span> <span class="k">in</span> <span class="n">execute_rx</span> <span class="p">{</span>
            <span class="c1">// snip</span>
            <span class="k">match</span> <span class="n">progress_bar</span> <span class="p">{</span>
                <span class="nf">Some</span><span class="p">(</span><span class="n">pb</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="c1">// snip</span>
                <span class="p">}</span>
                <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">progress_bars</span> <span class="o">=</span> <span class="n">progress_bars</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                    <span class="c1">// snip</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And in the <em>cli</em> module I added the call to <code class="language-plaintext highlighter-rouge">suspend()</code> when a return key was sent to stdin:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/cli.rs</span>

<span class="c1">// snip</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">start</span><span class="p">(</span><span class="n">progress_bars</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">MultiProgress</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">timer_register_tx</span><span class="p">:</span> <span class="nn">mpsc</span><span class="p">::</span><span class="n">Sender</span><span class="o">&lt;</span><span class="n">TimerArgs</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Press return to start adding a new timer"</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">input</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">()</span><span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">input</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">progress_bars</span> <span class="o">=</span> <span class="n">progress_bars</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="n">progress_bars</span><span class="nf">.suspend</span><span class="p">(||</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Provide stdin with a string in the following format to register a new timer:"</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"name repetitions interval(ms)"</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"e.g.: </span><span class="se">\"</span><span class="s">timer0 100 50</span><span class="se">\"</span><span class="s">"</span><span class="p">);</span>

            <span class="c1">// snip</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">this.rob.journal</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li><a href="mailto:this.rob@protonmail.com">this.rob@protonmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/thisdotrob"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">thisdotrob</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/thisdotrob"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">thisdotrob</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>A place to document and share my explorations in coding. Mainly so I can go back and copy paste when I forget how to do something ;)
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>

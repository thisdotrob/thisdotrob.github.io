---
layout: post
title:  "Learning Rust"
date:   2023-09-27 17:42:00 +0100
tags: ["Rust"]
---

Since leaving Shopify I've had the time to work out what I love about coding and what makes me passionate about it. My journey so far has seen me use a variety of languages but there's a long standing itch that I still haven't been able to scratch - working with a low level language on projects where performance is crucial.

At the very least I get the feeling that a developer should try writing something lower level in order to have a full appreciation for the magic offered by higher level languages. It's definitely something that has fed the imposter syndrome I sometimes feel. Not having a solid grounding in comp sci fundamentals (I arrived at coding through the bootcamp route) nor experience in lower level languages makes me less confident in technical discussions.

I've tried to address this over the years but it's difficult when I don't get a lot of time outside of work to pursue it. That's not the case right now as I can spend at least another couple of months before I need to get a new job. I plan to spend this time learning a lower level language and taking on an ambitious project in it that I would otherwise not get the chance to dedicate the necessary time to. If all goes to plan I'd love to get a job working in the language at the end of it. I feel like this will provide me with the technical, passion stoking challenges that I'd otherwise be struggling to squeeze in outside of work.

With progress in AI I also think this is the best bet I can place to future proof my career and make sure I can follow my passion whilst getting paid for it. Aside from jumping on the bandwagon and using the coding AI tools as an early adopter so I don't get left behind, re-focusing my expertise on the domains that I think AI tools will be the last to radically change seems sensible. I think there's a good chance that just as garbage collectors and other features of high level dynamic languages have already made building applications for lots of domains super easy for developers, freeing them up to be more product focused and less technical, these AI tools will potentially remove the need for coding all together at some point.

I'm motivated by building great customer facing applications, but I feel most passionate about building these applications where there is high technical complexity and performance is crucial. I'm hedging my bets that domains where performance and reliability are super important will be those that still require a decent amount of human coding, or at least auditing and tweaking of AI generated code. Hopefully for at least as long as I plan to work for. If not then early retirement to a minimalist lifestyle, writing code for archaic hardware in an air gapped cabin in the woods might be tempting.

The lower-level language I've picked to learn is Rust for the following reasons:
- it's modern but established with a seemingly great community and ecosystem,
- it's not just used for hardcore low level programming so my previous experience could flatten the learning curve,
- aside from c++ it looks to have the most active job market,
- it seems to offer maximal productivity for a lot of applications by providing the expressiveness, ergonomics and great compiler feedback needed to write code quickly *and* the safety, reliability and performance needed to minimise future fettling once it's "finished" and running.

Having seen the eye watering costs incurred in terms of dev time and running infrastructure at previous employers that used higher level languages it almost seems like a no-brainer choice of language if Rust's promises hold true. I know that the productivity promises of those higher level languages tend not to. On a less serious note I also love that Rust has a crab mascot, Ferris, since I consider myself a bit crablike (probably due to the [Barnum Effect](https://en.wikipedia.org/wiki/Barnum_effect) and being told I'm a good example of my Cancer star sign). The Rust logo [featuring a bicycle chainring](https://bugzilla.mozilla.org/show_bug.cgi?id=680521) also appeals to me as a two wheel nut.

My learning plan is as follows:
- Read ["the Rust book"](https://doc.rust-lang.org/stable/book/) and make notes in Logseq to later serve as a Rust knowledge graph.
- Try and use Rust instead of higher level scripting languages or spreadsheets for ad hoc tasks while I'm learning.
- Listen to as many Rust podcasts as possible.
- Possibly attempt [SICP](https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/index.html) in Rust. I've owned the book for a long time but never truely got stuck in.
- Investigate options for a long-term project that will allow me to put my newly acquired Rust skills into practice.
- [Advent of Code](https://adventofcode.com/) in Rust?
- Post updates on this blog as I go and talk as much as possible to others about what I'm learning to solidify the knowledge.

I'm excited about this new learning journey. I'm certain that the insight I gain from learning a lower level language will make me a better developer no matter what language I focus on in my next job. Exploring the differences between languages is just as important as having a deep expertise in the core concepts they share.

I'll finish with an apt quote from another (non-crab) Ferris about the importance of taking time out to check your priorities:

*"Life moves pretty fast. If you don't stop and look around once in a while, you could miss it."*
